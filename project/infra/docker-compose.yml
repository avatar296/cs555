services:
  kafka:
    image: bitnami/kafka:3.7
    container_name: kafka
    environment:
      - KAFKA_CFG_NODE_ID=1
      - KAFKA_CFG_PROCESS_ROLES=broker,controller
      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka:9093
      - KAFKA_CFG_LISTENERS=INTERNAL://:9092,EXTERNAL://:29092,CONTROLLER://:9093
      - KAFKA_CFG_ADVERTISED_LISTENERS=INTERNAL://kafka:9092,EXTERNAL://localhost:29092
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT,CONTROLLER:PLAINTEXT
      - KAFKA_CFG_INTER_BROKER_LISTENER_NAME=INTERNAL
      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true
      - KAFKA_CFG_NUM_PARTITIONS=12
      - KAFKA_CFG_TRANSACTION_STATE_LOG_REPLICATION_FACTOR=1
      - KAFKA_CFG_TRANSACTION_STATE_LOG_MIN_ISR=1
      - KAFKA_CFG_OFFSETS_TOPIC_REPLICATION_FACTOR=1
      - ALLOW_PLAINTEXT_LISTENER=yes
    ports:
      - "29092:29092"
    volumes:
      - kafka-data:/bitnami/kafka
    healthcheck:
      test: ["CMD", "bash", "-lc", "/opt/bitnami/kafka/bin/kafka-topics.sh --bootstrap-server localhost:9092 --list >/dev/null 2>&1"]
      interval: 10s
      timeout: 5s
      retries: 20

  # Schema Registry
  schema-registry:
    image: confluentinc/cp-schema-registry:7.5.0
    container_name: schema-registry
    depends_on:
      kafka:
        condition: service_healthy
    environment:
      - SCHEMA_REGISTRY_HOST_NAME=schema-registry
      - SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS=kafka:9092
      - SCHEMA_REGISTRY_LISTENERS=http://0.0.0.0:8081
    ports:
      - "8082:8081"  # Avoid conflict with Spark UI
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/subjects"]
      interval: 10s
      timeout: 5s
      retries: 5

  kafka-ui:
    image: provectuslabs/kafka-ui:latest
    container_name: kafka-ui
    depends_on:
      kafka:
        condition: service_healthy
      schema-registry:
        condition: service_healthy
    environment:
      - KAFKA_CLUSTERS_0_NAME=local
      - KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=kafka:9092
      - KAFKA_CLUSTERS_0_SCHEMAREGISTRY=http://schema-registry:8081
    ports:
      - "8080:8080"

  # NYC Taxi Event Stream Producer
  producer:
    build:
      context: ..
      dockerfile: producer/Dockerfile
    container_name: producer
    depends_on:
      kafka:
        condition: service_healthy
      schema-registry:
        condition: service_healthy
    environment:
      # Kafka Connection (internal Docker network)
      - KAFKA_BOOTSTRAP_SERVERS=kafka:9092
      - SCHEMA_REGISTRY_URL=http://schema-registry:8081

      # Stream Configuration (continuous mode)
      - TRIP_RATE=500
      - TRIP_TOTAL_EVENTS=-1
      - TRIP_ERROR_RATE=0.0

      - WEATHER_RATE=10
      - WEATHER_TOTAL_EVENTS=-1
      - WEATHER_ERROR_RATE=0.0

      - EVENT_RATE=0.1
      - EVENT_TOTAL_EVENTS=-1
      - EVENT_ERROR_RATE=0.0

      # Timing
      - USE_REALTIME=true
      - TIME_PROGRESSION_SECONDS=1
    restart: unless-stopped

  # MinIO Object Storage
  minio:
    image: minio/minio:latest
    container_name: minio
    command: server /data --console-address ":9001"
    environment:
      - MINIO_ROOT_USER=admin
      - MINIO_ROOT_PASSWORD=admin123
    ports:
      - "9000:9000"  # S3 API
      - "9001:9001"  # Web Console
    volumes:
      - minio-data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 5s
      timeout: 5s
      retries: 5

  # MinIO Bucket Setup
  minio-setup:
    image: minio/mc:latest
    container_name: minio-setup
    depends_on:
      minio:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      mc alias set minio http://minio:9000 admin admin123;
      mc mb minio/lakehouse || true;
      mc anonymous set download minio/lakehouse;
      echo 'MinIO bucket created';
      exit 0;
      "

  # PostgreSQL for Iceberg Catalog (JDBC)
  postgres-iceberg:
    image: postgres:15
    container_name: postgres-iceberg
    environment:
      - POSTGRES_DB=iceberg
      - POSTGRES_USER=iceberg
      - POSTGRES_PASSWORD=iceberg123
    ports:
      - "5432:5432"
    volumes:
      - postgres-iceberg-data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U iceberg -d iceberg"]
      interval: 5s
      timeout: 5s
      retries: 5

  # Spark Master
  spark-master:
    build: ./spark
    image: project-spark:3.5.0
    container_name: spark-master
    command: /opt/spark/bin/spark-class org.apache.spark.deploy.master.Master
    depends_on:
      minio:
        condition: service_healthy
      postgres-iceberg:
        condition: service_healthy
    environment:
      - SPARK_MASTER_HOST=spark-master
      - SPARK_MASTER_PORT=7077
      - SPARK_MASTER_WEBUI_PORT=8080
      - SPARK_NO_DAEMONIZE=true
      # Iceberg Catalog Configuration (JDBC)
      - SPARK_DEFAULTS_spark.sql.extensions=org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions
      - SPARK_DEFAULTS_spark.sql.catalog.lakehouse=org.apache.iceberg.spark.SparkCatalog
      - SPARK_DEFAULTS_spark.sql.catalog.lakehouse.type=jdbc
      - SPARK_DEFAULTS_spark.sql.catalog.lakehouse.uri=jdbc:postgresql://postgres-iceberg:5432/iceberg
      - SPARK_DEFAULTS_spark.sql.catalog.lakehouse.jdbc.user=iceberg
      - SPARK_DEFAULTS_spark.sql.catalog.lakehouse.jdbc.password=iceberg123
      - SPARK_DEFAULTS_spark.sql.catalog.lakehouse.warehouse=s3a://lakehouse/warehouse
      # MinIO S3 Configuration
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    ports:
      - "8081:8080"  # Spark Master Web UI
      - "7077:7077"  # Spark Master Port
    volumes:
      - ../lakehouse/bronze/build/libs:/opt/spark/work-dir/jars/bronze
      - ../lakehouse/silver/build/libs:/opt/spark/work-dir/jars/silver
      - ../lakehouse/gold/build/libs:/opt/spark/work-dir/jars/gold
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
      - spark-logs:/opt/spark/logs
      - spark-state:/tmp/state-store

  # Spark Workers (Scaled for Bronze Layer)
  spark-worker:
    build: ./spark
    image: project-spark:3.5.0
    command: /opt/spark/bin/spark-class org.apache.spark.deploy.worker.Worker spark://spark-master:7077
    depends_on:
      - spark-master
      - minio
      - postgres-iceberg
    environment:
      - SPARK_WORKER_CORES=2
      - SPARK_WORKER_MEMORY=2g
      - SPARK_NO_DAEMONIZE=true
      # Enable External Shuffle Service (required for dynamic allocation)
      - SPARK_WORKER_OPTS=-Dspark.shuffle.service.enabled=true -Dspark.shuffle.service.port=7337
      # MinIO S3 Configuration
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/bronze/build/libs:/opt/spark/work-dir/jars/bronze
      - ../lakehouse/silver/build/libs:/opt/spark/work-dir/jars/silver
      - ../lakehouse/gold/build/libs:/opt/spark/work-dir/jars/gold
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
      - spark-logs:/opt/spark/logs
      - spark-state:/tmp/state-store
    deploy:
      replicas: 2  # 2 workers = 4 cores, 4GB total

  # Schema Management - Bronze Layer Table Setup
  bronze-table-setup:
    image: project-spark:3.5.0
    container_name: bronze-table-setup
    command: >
      /opt/spark/bin/spark-submit
      --class csx55.sta.schema.SchemaManagementApp
      --master spark://spark-master:7077
      --deploy-mode client
      --conf spark.driver.memory=1g
      --conf spark.executor.memory=1g
      --conf spark.hadoop.fs.s3a.access.key=admin
      --conf spark.hadoop.fs.s3a.secret.key=admin123
      --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
      --conf spark.hadoop.fs.s3a.path.style.access=true
      /opt/spark/work-dir/jars/schema/schema-management.jar
      bronze
    depends_on:
      spark-master:
        condition: service_started
      kafka:
        condition: service_healthy
      schema-registry:
        condition: service_healthy
      minio:
        condition: service_healthy
      postgres-iceberg:
        condition: service_healthy

    environment:
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/schema-management/build/libs:/opt/spark/work-dir/jars/schema
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
    restart: on-failure
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G

  # Bronze Layer Streaming Jobs
  bronze-trips-consumer:
    image: project-spark:3.5.0
    container_name: bronze-trips-consumer
    command: >
      /opt/spark/bin/spark-submit
      --class csx55.sta.bronze.jobs.TripsBronzeJob
      --master spark://spark-master:7077
      --deploy-mode client
      --conf spark.driver.memory=512m
      --conf spark.executor.memory=1g
      --conf spark.executor.cores=1
      --conf spark.dynamicAllocation.enabled=true
      --conf spark.dynamicAllocation.shuffleTracking.enabled=true
      --conf spark.dynamicAllocation.minExecutors=0
      --conf spark.dynamicAllocation.maxExecutors=2
      --conf spark.dynamicAllocation.initialExecutors=1
      --conf spark.dynamicAllocation.executorIdleTimeout=60s
      --conf spark.dynamicAllocation.schedulerBacklogTimeout=5s
      --conf spark.shuffle.service.enabled=true
      --conf spark.streaming.kafka.maxRatePerPartition=1000
      --conf spark.sql.streaming.minBatchesToRetain=10
      --conf spark.hadoop.fs.s3a.access.key=admin
      --conf spark.hadoop.fs.s3a.secret.key=admin123
      --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
      --conf spark.hadoop.fs.s3a.path.style.access=true
      /opt/spark/work-dir/jars/bronze/bronze.jar
    depends_on:
      bronze-table-setup:
        condition: service_completed_successfully
      spark-master:
        condition: service_started
      kafka:
        condition: service_healthy
      schema-registry:
        condition: service_healthy
      minio:
        condition: service_healthy
      postgres-iceberg:
        condition: service_healthy
    environment:
      # MinIO S3 Configuration (for checkpoints)
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/bronze/build/libs:/opt/spark/work-dir/jars/bronze
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
      - spark-logs:/opt/spark/logs
      - spark-state:/tmp/state-store
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 1G
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4040/api/v1/applications"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    stop_grace_period: 120s
    restart: unless-stopped

  bronze-weather-consumer:
    image: project-spark:3.5.0
    container_name: bronze-weather-consumer
    command: >
      /opt/spark/bin/spark-submit
      --class csx55.sta.bronze.jobs.WeatherBronzeJob
      --master spark://spark-master:7077
      --deploy-mode client
      --conf spark.driver.memory=512m
      --conf spark.executor.memory=1g
      --conf spark.executor.cores=1
      --conf spark.dynamicAllocation.enabled=true
      --conf spark.dynamicAllocation.shuffleTracking.enabled=true
      --conf spark.dynamicAllocation.minExecutors=0
      --conf spark.dynamicAllocation.maxExecutors=2
      --conf spark.dynamicAllocation.initialExecutors=1
      --conf spark.dynamicAllocation.executorIdleTimeout=60s
      --conf spark.dynamicAllocation.schedulerBacklogTimeout=5s
      --conf spark.shuffle.service.enabled=true
      --conf spark.streaming.kafka.maxRatePerPartition=1000
      --conf spark.sql.streaming.minBatchesToRetain=10
      --conf spark.hadoop.fs.s3a.access.key=admin
      --conf spark.hadoop.fs.s3a.secret.key=admin123
      --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
      --conf spark.hadoop.fs.s3a.path.style.access=true
      /opt/spark/work-dir/jars/bronze/bronze.jar
    depends_on:
      bronze-table-setup:
        condition: service_completed_successfully
      spark-master:
        condition: service_started
      kafka:
        condition: service_healthy
      schema-registry:
        condition: service_healthy
      minio:
        condition: service_healthy
      postgres-iceberg:
        condition: service_healthy
    environment:
      # MinIO S3 Configuration (for checkpoints)
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/bronze/build/libs:/opt/spark/work-dir/jars/bronze
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
      - spark-logs:/opt/spark/logs
      - spark-state:/tmp/state-store
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 1G
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4040/api/v1/applications"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    stop_grace_period: 120s
    restart: unless-stopped

  bronze-events-consumer:
    image: project-spark:3.5.0
    container_name: bronze-events-consumer
    command: >
      /opt/spark/bin/spark-submit
      --class csx55.sta.bronze.jobs.EventsBronzeJob
      --master spark://spark-master:7077
      --deploy-mode client
      --conf spark.driver.memory=512m
      --conf spark.executor.memory=1g
      --conf spark.executor.cores=1
      --conf spark.dynamicAllocation.enabled=true
      --conf spark.dynamicAllocation.shuffleTracking.enabled=true
      --conf spark.dynamicAllocation.minExecutors=0
      --conf spark.dynamicAllocation.maxExecutors=2
      --conf spark.dynamicAllocation.initialExecutors=1
      --conf spark.dynamicAllocation.executorIdleTimeout=60s
      --conf spark.dynamicAllocation.schedulerBacklogTimeout=5s
      --conf spark.shuffle.service.enabled=true
      --conf spark.streaming.kafka.maxRatePerPartition=1000
      --conf spark.sql.streaming.minBatchesToRetain=10
      --conf spark.hadoop.fs.s3a.access.key=admin
      --conf spark.hadoop.fs.s3a.secret.key=admin123
      --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
      --conf spark.hadoop.fs.s3a.path.style.access=true
      /opt/spark/work-dir/jars/bronze/bronze.jar
    depends_on:
      bronze-table-setup:
        condition: service_completed_successfully
      spark-master:
        condition: service_started
      kafka:
        condition: service_healthy
      schema-registry:
        condition: service_healthy
      minio:
        condition: service_healthy
      postgres-iceberg:
        condition: service_healthy
    environment:
      # MinIO S3 Configuration (for checkpoints)
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/bronze/build/libs:/opt/spark/work-dir/jars/bronze
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
      - spark-logs:/opt/spark/logs
      - spark-state:/tmp/state-store
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 1G
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4040/api/v1/applications"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    stop_grace_period: 120s
    restart: unless-stopped

volumes:
  kafka-data:
  spark-logs:
  spark-state:
  minio-data:
  postgres-iceberg-data:
