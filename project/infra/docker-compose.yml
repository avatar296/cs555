services:
  # =========================================================================
  # KAFKA
  # =========================================================================
  kafka:
    image: bitnami/kafka:3.7
    container_name: kafka
    environment:
      - KAFKA_CFG_NODE_ID=1
      - KAFKA_CFG_PROCESS_ROLES=broker,controller
      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=1@kafka:9093
      - KAFKA_CFG_LISTENERS=INTERNAL://:9092,EXTERNAL://:29092,CONTROLLER://:9093
      - KAFKA_CFG_ADVERTISED_LISTENERS=INTERNAL://kafka:9092,EXTERNAL://localhost:29092
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT,CONTROLLER:PLAINTEXT
      - KAFKA_CFG_INTER_BROKER_LISTENER_NAME=INTERNAL
      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER
      - KAFKA_CFG_AUTO_CREATE_TOPICS_ENABLE=true
      - KAFKA_CFG_NUM_PARTITIONS=12
      - KAFKA_CFG_TRANSACTION_STATE_LOG_REPLICATION_FACTOR=1
      - KAFKA_CFG_TRANSACTION_STATE_LOG_MIN_ISR=1
      - KAFKA_CFG_OFFSETS_TOPIC_REPLICATION_FACTOR=1
      - ALLOW_PLAINTEXT_LISTENER=yes
    ports:
      - "29092:29092"
    volumes:
      - kafka-data:/bitnami/kafka
    healthcheck:
      test: ["CMD", "bash", "-lc", "/opt/bitnami/kafka/bin/kafka-topics.sh --bootstrap-server localhost:9092 --list >/dev/null 2>&1"]
      interval: 10s
      timeout: 5s
      retries: 20

  schema-registry:
    image: confluentinc/cp-schema-registry:7.5.0
    container_name: schema-registry
    depends_on:
      kafka:
        condition: service_healthy
    environment:
      - SCHEMA_REGISTRY_HOST_NAME=schema-registry
      - SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS=kafka:9092
      - SCHEMA_REGISTRY_LISTENERS=http://0.0.0.0:8081
    ports:
      - "8082:8081"  # Avoid conflict with Spark UI
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/subjects"]
      interval: 10s
      timeout: 5s
      retries: 5

  kafka-ui:
    image: provectuslabs/kafka-ui:latest
    container_name: kafka-ui
    depends_on:
      kafka:
        condition: service_healthy
      schema-registry:
        condition: service_healthy
    environment:
      - KAFKA_CLUSTERS_0_NAME=local
      - KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=kafka:9092
      - KAFKA_CLUSTERS_0_SCHEMAREGISTRY=http://schema-registry:8081
    ports:
      - "8080:8080"

  # =========================================================================
  # PRODUCER
  # =========================================================================

  producer:
    build:
      context: ..
      dockerfile: producer/Dockerfile
    container_name: producer
    depends_on:
      kafka:
        condition: service_healthy
      schema-registry:
        condition: service_healthy
    environment:
      # Kafka Connection (internal Docker network)
      - KAFKA_BOOTSTRAP_SERVERS=kafka:9092
      - SCHEMA_REGISTRY_URL=http://schema-registry:8081

      # Stream Configuration (continuous mode)
      - TRIP_RATE=500
      - TRIP_TOTAL_EVENTS=-1
      - TRIP_ERROR_RATE=0.0

      - WEATHER_RATE=10
      - WEATHER_TOTAL_EVENTS=-1
      - WEATHER_ERROR_RATE=0.0

      - EVENT_RATE=0.1
      - EVENT_TOTAL_EVENTS=-1
      - EVENT_ERROR_RATE=0.0

      # Timing
      - USE_REALTIME=true
      - TIME_PROGRESSION_SECONDS=1
    restart: unless-stopped


  # =========================================================================
  # STORAGE & CATALOG
  # =========================================================================

  minio:
    image: minio/minio:latest
    container_name: minio
    command: server /data --console-address ":9001"
    environment:
      - MINIO_ROOT_USER=admin
      - MINIO_ROOT_PASSWORD=admin123
    ports:
      - "9000:9000"  # S3 API
      - "9001:9001"  # Web Console
    volumes:
      - minio-data:/data
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 5s
      timeout: 5s
      retries: 5

  minio-setup:
    image: minio/mc:latest
    container_name: minio-setup
    depends_on:
      minio:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      mc alias set minio http://minio:9000 admin admin123;
      mc mb minio/lakehouse || true;
      mc anonymous set download minio/lakehouse;
      echo 'MinIO bucket created';
      exit 0;
      "

  postgres-iceberg:
    image: postgres:15
    container_name: postgres-iceberg
    environment:
      - POSTGRES_DB=iceberg
      - POSTGRES_USER=iceberg
      - POSTGRES_PASSWORD=iceberg123
    ports:
      - "5432:5432"
    volumes:
      - postgres-iceberg-data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U iceberg -d iceberg"]
      interval: 5s
      timeout: 5s
      retries: 5

  # =========================================================================
  # SPARK
  # =========================================================================

  spark-master:
    build: ./spark
    image: project-spark:3.5.0
    container_name: spark-master
    command: /opt/spark/bin/spark-class org.apache.spark.deploy.master.Master
    depends_on:
      minio:
        condition: service_healthy
      postgres-iceberg:
        condition: service_healthy
    environment:
      - SPARK_MASTER_HOST=spark-master
      - SPARK_MASTER_PORT=7077
      - SPARK_MASTER_WEBUI_PORT=8080
      - SPARK_NO_DAEMONIZE=true
      # Iceberg Catalog Configuration (JDBC)
      - SPARK_DEFAULTS_spark.sql.extensions=org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions
      - SPARK_DEFAULTS_spark.sql.catalog.lakehouse=org.apache.iceberg.spark.SparkCatalog
      - SPARK_DEFAULTS_spark.sql.catalog.lakehouse.type=jdbc
      - SPARK_DEFAULTS_spark.sql.catalog.lakehouse.uri=jdbc:postgresql://postgres-iceberg:5432/iceberg
      - SPARK_DEFAULTS_spark.sql.catalog.lakehouse.jdbc.user=iceberg
      - SPARK_DEFAULTS_spark.sql.catalog.lakehouse.jdbc.password=iceberg123
      - SPARK_DEFAULTS_spark.sql.catalog.lakehouse.warehouse=s3a://lakehouse/warehouse
      # MinIO S3 Configuration
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    ports:
      - "8081:8080"  # Spark Master Web UI
      - "7077:7077"  # Spark Master Port
    volumes:
      - ../lakehouse/bronze/build/libs:/opt/spark/work-dir/jars/bronze
      - ../lakehouse/silver/build/libs:/opt/spark/work-dir/jars/silver
      - ../lakehouse/gold/build/libs:/opt/spark/work-dir/jars/gold
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
      - spark-logs:/opt/spark/logs
      - spark-state:/tmp/state-store

  spark-worker:
    build: ./spark
    image: project-spark:3.5.0
    command: /opt/spark/bin/spark-class org.apache.spark.deploy.worker.Worker spark://spark-master:7077
    depends_on:
      - spark-master
      - minio
      - postgres-iceberg
    environment:
      - SPARK_WORKER_CORES=2
      - SPARK_WORKER_MEMORY=2g
      - SPARK_NO_DAEMONIZE=true
      # Enable External Shuffle Service (required for dynamic allocation)
      - SPARK_WORKER_OPTS=-Dspark.shuffle.service.enabled=true -Dspark.shuffle.service.port=7337
      # MinIO S3 Configuration
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/bronze/build/libs:/opt/spark/work-dir/jars/bronze
      - ../lakehouse/silver/build/libs:/opt/spark/work-dir/jars/silver
      - ../lakehouse/gold/build/libs:/opt/spark/work-dir/jars/gold
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
      - spark-logs:/opt/spark/logs
      - spark-state:/tmp/state-store
    deploy:
      replicas: 2  # 2 workers = 4 cores, 4GB total (right-sized for 512MB executors)

  # =========================================================================
  # BRONZE
  # =========================================================================

  bronze-table-setup:
    image: project-spark:3.5.0
    container_name: bronze-table-setup
    command: >
      /opt/spark/bin/spark-submit
      --class csx55.sta.schema.SchemaManagementApp
      --master spark://spark-master:7077
      --deploy-mode client
      --conf spark.driver.memory=1g
      --conf spark.executor.memory=1g
      --conf spark.hadoop.fs.s3a.access.key=admin
      --conf spark.hadoop.fs.s3a.secret.key=admin123
      --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
      --conf spark.hadoop.fs.s3a.path.style.access=true
      /opt/spark/work-dir/jars/schema/schema-management.jar
      bronze
    depends_on:
      spark-master:
        condition: service_started
      kafka:
        condition: service_healthy
      schema-registry:
        condition: service_healthy
      minio:
        condition: service_healthy
      postgres-iceberg:
        condition: service_healthy
    environment:
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/schema-management/build/libs:/opt/spark/work-dir/jars/schema
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
    restart: on-failure
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G

  bronze-trips-consumer:
    image: project-spark:3.5.0
    container_name: bronze-trips-consumer
    command: >
      /opt/spark/bin/spark-submit
      --class csx55.sta.bronze.jobs.TripsBronzeJob
      --master spark://spark-master:7077
      --deploy-mode client
      --conf spark.driver.memory=512m
      --conf spark.executor.memory=512m
      --conf spark.executor.cores=1
      --conf spark.dynamicAllocation.enabled=true
      --conf spark.dynamicAllocation.shuffleTracking.enabled=true
      --conf spark.dynamicAllocation.minExecutors=0
      --conf spark.dynamicAllocation.maxExecutors=2
      --conf spark.dynamicAllocation.initialExecutors=1
      --conf spark.dynamicAllocation.executorIdleTimeout=60s
      --conf spark.dynamicAllocation.schedulerBacklogTimeout=5s
      --conf spark.shuffle.service.enabled=true
      --conf spark.streaming.kafka.maxRatePerPartition=1000
      --conf spark.sql.streaming.minBatchesToRetain=10
      --conf spark.driver.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
      --conf spark.executor.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
      --conf spark.hadoop.fs.s3a.access.key=admin
      --conf spark.hadoop.fs.s3a.secret.key=admin123
      --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
      --conf spark.hadoop.fs.s3a.path.style.access=true
      /opt/spark/work-dir/jars/bronze/bronze.jar
    depends_on:
      bronze-table-setup:
        condition: service_completed_successfully
      spark-master:
        condition: service_started
      kafka:
        condition: service_healthy
      schema-registry:
        condition: service_healthy
      minio:
        condition: service_healthy
      postgres-iceberg:
        condition: service_healthy
    environment:
      # MinIO S3 Configuration (for checkpoints)
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/bronze/build/libs:/opt/spark/work-dir/jars/bronze
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
      - spark-logs:/opt/spark/logs
      - spark-state:/tmp/state-store
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 1G
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4040/api/v1/applications"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    stop_grace_period: 120s
    restart: unless-stopped

  # bronze-weather-consumer:
  #   image: project-spark:3.5.0
  #   container_name: bronze-weather-consumer
  #   command: >
  #     /opt/spark/bin/spark-submit
  #     --class csx55.sta.bronze.jobs.WeatherBronzeJob
  #     --master spark://spark-master:7077
  #     --deploy-mode client
  #     --conf spark.driver.memory=512m
  #     --conf spark.executor.memory=512m
  #     --conf spark.executor.cores=1
  #     --conf spark.dynamicAllocation.enabled=true
  #     --conf spark.dynamicAllocation.shuffleTracking.enabled=true
  #     --conf spark.dynamicAllocation.minExecutors=0
  #     --conf spark.dynamicAllocation.maxExecutors=2
  #     --conf spark.dynamicAllocation.initialExecutors=1
  #     --conf spark.dynamicAllocation.executorIdleTimeout=60s
  #     --conf spark.dynamicAllocation.schedulerBacklogTimeout=5s
  #     --conf spark.shuffle.service.enabled=true
  #     --conf spark.streaming.kafka.maxRatePerPartition=1000
  #     --conf spark.sql.streaming.minBatchesToRetain=10
  #     --conf spark.driver.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
  #     --conf spark.executor.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
  #     --conf spark.hadoop.fs.s3a.access.key=admin
  #     --conf spark.hadoop.fs.s3a.secret.key=admin123
  #     --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
  #     --conf spark.hadoop.fs.s3a.path.style.access=true
  #     /opt/spark/work-dir/jars/bronze/bronze.jar
  #   depends_on:
  #     bronze-table-setup:
  #       condition: service_completed_successfully
  #     spark-master:
  #       condition: service_started
  #     kafka:
  #       condition: service_healthy
  #     schema-registry:
  #       condition: service_healthy
  #     minio:
  #       condition: service_healthy
  #     postgres-iceberg:
  #       condition: service_healthy
  #   environment:
  #     # MinIO S3 Configuration (for checkpoints)
  #     - AWS_ACCESS_KEY_ID=admin
  #     - AWS_SECRET_ACCESS_KEY=admin123
  #     - AWS_REGION=us-east-1
  #   volumes:
  #     - ../lakehouse/bronze/build/libs:/opt/spark/work-dir/jars/bronze
  #     - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
  #     - spark-logs:/opt/spark/logs
  #     - spark-state:/tmp/state-store
  #   deploy:
  #     resources:
  #       limits:
  #         cpus: '1.0'
  #         memory: 2G
  #       reservations:
  #         cpus: '0.5'
  #         memory: 1G
  #   healthcheck:
  #     test: ["CMD", "curl", "-f", "http://localhost:4040/api/v1/applications"]
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 60s
  #   stop_grace_period: 120s
  #   restart: unless-stopped

  # bronze-events-consumer:
  #   image: project-spark:3.5.0
  #   container_name: bronze-events-consumer
  #   command: >
  #     /opt/spark/bin/spark-submit
  #     --class csx55.sta.bronze.jobs.EventsBronzeJob
  #     --master spark://spark-master:7077
  #     --deploy-mode client
  #     --conf spark.driver.memory=512m
  #     --conf spark.executor.memory=512m
  #     --conf spark.executor.cores=1
  #     --conf spark.dynamicAllocation.enabled=true
  #     --conf spark.dynamicAllocation.shuffleTracking.enabled=true
  #     --conf spark.dynamicAllocation.minExecutors=0
  #     --conf spark.dynamicAllocation.maxExecutors=2
  #     --conf spark.dynamicAllocation.initialExecutors=1
  #     --conf spark.dynamicAllocation.executorIdleTimeout=60s
  #     --conf spark.dynamicAllocation.schedulerBacklogTimeout=5s
  #     --conf spark.shuffle.service.enabled=true
  #     --conf spark.streaming.kafka.maxRatePerPartition=1000
  #     --conf spark.sql.streaming.minBatchesToRetain=10
  #     --conf spark.driver.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
  #     --conf spark.executor.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
  #     --conf spark.hadoop.fs.s3a.access.key=admin
  #     --conf spark.hadoop.fs.s3a.secret.key=admin123
  #     --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
  #     --conf spark.hadoop.fs.s3a.path.style.access=true
  #     /opt/spark/work-dir/jars/bronze/bronze.jar
  #   depends_on:
  #     bronze-table-setup:
  #       condition: service_completed_successfully
  #     spark-master:
  #       condition: service_started
  #     kafka:
  #       condition: service_healthy
  #     schema-registry:
  #       condition: service_healthy
  #     minio:
  #       condition: service_healthy
  #     postgres-iceberg:
  #       condition: service_healthy
  #   environment:
  #     # MinIO S3 Configuration (for checkpoints)
  #     - AWS_ACCESS_KEY_ID=admin
  #     - AWS_SECRET_ACCESS_KEY=admin123
  #     - AWS_REGION=us-east-1
  #   volumes:
  #     - ../lakehouse/bronze/build/libs:/opt/spark/work-dir/jars/bronze
  #     - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
  #     - spark-logs:/opt/spark/logs
  #     - spark-state:/tmp/state-store
  #   deploy:
  #     resources:
  #       limits:
  #         cpus: '1.0'
  #         memory: 2G
  #       reservations:
  #         cpus: '0.5'
  #         memory: 1G
  #   healthcheck:
  #     test: ["CMD", "curl", "-f", "http://localhost:4040/api/v1/applications"]
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 60s
  #   stop_grace_period: 120s
  #   restart: unless-stopped

  # =========================================================================
  # SILVER
  # =========================================================================

  monitoring-table-setup:
    image: project-spark:3.5.0
    container_name: monitoring-table-setup
    command: >
      /opt/spark/bin/spark-submit
      --class csx55.sta.schema.SchemaManagementApp
      --master spark://spark-master:7077
      --deploy-mode client
      --conf spark.driver.memory=512m
      --conf spark.executor.memory=1g
      --conf spark.hadoop.fs.s3a.access.key=admin
      --conf spark.hadoop.fs.s3a.secret.key=admin123
      --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
      --conf spark.hadoop.fs.s3a.path.style.access=true
      /opt/spark/work-dir/jars/schema/schema-management.jar
      monitoring
    depends_on:
      spark-master:
        condition: service_started
      minio:
        condition: service_healthy
      postgres-iceberg:
        condition: service_healthy
    environment:
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/schema-management/build/libs:/opt/spark/work-dir/jars/schema
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
    restart: on-failure
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G

  silver-table-setup:
    image: project-spark:3.5.0
    container_name: silver-table-setup
    command: >
      /opt/spark/bin/spark-submit
      --class csx55.sta.schema.SchemaManagementApp
      --master spark://spark-master:7077
      --deploy-mode client
      --conf spark.driver.memory=512m
      --conf spark.executor.memory=1g
      --conf spark.hadoop.fs.s3a.access.key=admin
      --conf spark.hadoop.fs.s3a.secret.key=admin123
      --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
      --conf spark.hadoop.fs.s3a.path.style.access=true
      /opt/spark/work-dir/jars/schema/schema-management.jar
      silver
    depends_on:
      monitoring-table-setup:
        condition: service_completed_successfully
      spark-master:
        condition: service_started
      minio:
        condition: service_healthy
      postgres-iceberg:
        condition: service_healthy
    environment:
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/schema-management/build/libs:/opt/spark/work-dir/jars/schema
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
    restart: on-failure
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G

  silver-trips-consumer:
    image: project-spark:3.5.0
    container_name: silver-trips-consumer
    command: >
      /opt/spark/bin/spark-submit
      --class csx55.sta.silver.jobs.TripsCleanedJob
      --master spark://spark-master:7077
      --deploy-mode client
      --conf spark.driver.memory=2g
      --conf spark.executor.memory=2g
      --conf spark.executor.cores=1
      --conf spark.dynamicAllocation.enabled=true
      --conf spark.dynamicAllocation.shuffleTracking.enabled=true
      --conf spark.dynamicAllocation.minExecutors=1
      --conf spark.dynamicAllocation.maxExecutors=2
      --conf spark.dynamicAllocation.initialExecutors=1
      --conf spark.dynamicAllocation.executorIdleTimeout=60s
      --conf spark.dynamicAllocation.schedulerBacklogTimeout=5s
      --conf spark.shuffle.service.enabled=true
      --conf spark.streaming.kafka.maxRatePerPartition=1000
      --conf spark.sql.streaming.minBatchesToRetain=10
      --conf spark.driver.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
      --conf spark.executor.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
      --conf spark.hadoop.fs.s3a.access.key=admin
      --conf spark.hadoop.fs.s3a.secret.key=admin123
      --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
      --conf spark.hadoop.fs.s3a.path.style.access=true
      /opt/spark/work-dir/jars/silver/silver.jar
    depends_on:
      silver-table-setup:
        condition: service_completed_successfully
      spark-master:
        condition: service_started
    environment:
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/silver/build/libs:/opt/spark/work-dir/jars/silver
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
      - spark-logs:/opt/spark/logs
      - spark-state:/tmp/state-store
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 3G
        reservations:
          cpus: '0.5'
          memory: 1G
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4040/api/v1/applications"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    stop_grace_period: 120s
    restart: unless-stopped

  # silver-weather-consumer:
  #   image: project-spark:3.5.0
  #   container_name: silver-weather-consumer
  #   command: >
  #     /opt/spark/bin/spark-submit
  #     --class csx55.sta.silver.jobs.WeatherCleanedJob
  #     --master spark://spark-master:7077
  #     --deploy-mode client
  #     --conf spark.driver.memory=2g
  #     --conf spark.executor.memory=2g
  #     --conf spark.executor.cores=1
  #     --conf spark.dynamicAllocation.enabled=true
  #     --conf spark.dynamicAllocation.shuffleTracking.enabled=true
  #     --conf spark.dynamicAllocation.minExecutors=1
  #     --conf spark.dynamicAllocation.maxExecutors=2
  #     --conf spark.dynamicAllocation.initialExecutors=1
  #     --conf spark.dynamicAllocation.executorIdleTimeout=60s
  #     --conf spark.dynamicAllocation.schedulerBacklogTimeout=5s
  #     --conf spark.shuffle.service.enabled=true
  #     --conf spark.streaming.kafka.maxRatePerPartition=1000
  #     --conf spark.sql.streaming.minBatchesToRetain=10
  #     --conf spark.driver.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
  #     --conf spark.executor.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
  #     --conf spark.hadoop.fs.s3a.access.key=admin
  #     --conf spark.hadoop.fs.s3a.secret.key=admin123
  #     --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
  #     --conf spark.hadoop.fs.s3a.path.style.access=true
  #     /opt/spark/work-dir/jars/silver/silver.jar
  #   depends_on:
  #     bronze-weather-consumer:
  #       condition: service_started
  #     spark-master:
  #       condition: service_started
  #   environment:
  #     - AWS_ACCESS_KEY_ID=admin
  #     - AWS_SECRET_ACCESS_KEY=admin123
  #     - AWS_REGION=us-east-1
  #   volumes:
  #     - ../lakehouse/silver/build/libs:/opt/spark/work-dir/jars/silver
  #     - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
  #     - spark-logs:/opt/spark/logs
  #     - spark-state:/tmp/state-store
  #   deploy:
  #     resources:
  #       limits:
  #         cpus: '1.0'
  #         memory: 3G
  #       reservations:
  #         cpus: '0.5'
  #         memory: 1G
  #   healthcheck:
  #     test: ["CMD", "curl", "-f", "http://localhost:4040/api/v1/applications"]
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 60s
  #   stop_grace_period: 120s
  #   restart: unless-stopped

  # silver-events-consumer:
  #   image: project-spark:3.5.0
  #   container_name: silver-events-consumer
  #   command: >
  #     /opt/spark/bin/spark-submit
  #     --class csx55.sta.silver.jobs.EventsCleanedJob
  #     --master spark://spark-master:7077
  #     --deploy-mode client
  #     --conf spark.driver.memory=2g
  #     --conf spark.executor.memory=2g
  #     --conf spark.executor.cores=1
  #     --conf spark.dynamicAllocation.enabled=true
  #     --conf spark.dynamicAllocation.shuffleTracking.enabled=true
  #     --conf spark.dynamicAllocation.minExecutors=1
  #     --conf spark.dynamicAllocation.maxExecutors=2
  #     --conf spark.dynamicAllocation.initialExecutors=1
  #     --conf spark.dynamicAllocation.executorIdleTimeout=60s
  #     --conf spark.dynamicAllocation.schedulerBacklogTimeout=5s
  #     --conf spark.shuffle.service.enabled=true
  #     --conf spark.streaming.kafka.maxRatePerPartition=1000
  #     --conf spark.sql.streaming.minBatchesToRetain=10
  #     --conf spark.driver.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
  #     --conf spark.executor.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
  #     --conf spark.hadoop.fs.s3a.access.key=admin
  #     --conf spark.hadoop.fs.s3a.secret.key=admin123
  #     --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
  #     --conf spark.hadoop.fs.s3a.path.style.access=true
  #     /opt/spark/work-dir/jars/silver/silver.jar
  #   depends_on:
  #     silver-table-setup:
  #       condition: service_completed_successfully
  #     spark-master:
  #       condition: service_started
  #   environment:
  #     - AWS_ACCESS_KEY_ID=admin
  #     - AWS_SECRET_ACCESS_KEY=admin123
  #     - AWS_REGION=us-east-1
  #   volumes:
  #     - ../lakehouse/silver/build/libs:/opt/spark/work-dir/jars/silver
  #     - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
  #     - spark-logs:/opt/spark/logs
  #     - spark-state:/tmp/state-store
  #   deploy:
  #     resources:
  #       limits:
  #         cpus: '1.0'
  #         memory: 1G
  #       reservations:
  #         cpus: '0.5'
  #         memory: 512M
  #   healthcheck:
  #     test: ["CMD", "curl", "-f", "http://localhost:4040/api/v1/applications"]
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #     start_period: 60s
  #   stop_grace_period: 120s
  #   restart: unless-stopped

  # =========================================================================
  # GOLD
  # =========================================================================

  gold-table-setup:
    image: project-spark:3.5.0
    container_name: gold-table-setup
    command: >
      /opt/spark/bin/spark-submit
      --class csx55.sta.schema.SchemaManagementApp
      --master spark://spark-master:7077
      --deploy-mode client
      --conf spark.driver.memory=512m
      --conf spark.executor.memory=512m
      --conf spark.hadoop.fs.s3a.access.key=admin
      --conf spark.hadoop.fs.s3a.secret.key=admin123
      --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
      --conf spark.hadoop.fs.s3a.path.style.access=true
      /opt/spark/work-dir/jars/schema-management/schema-management.jar
      gold
    depends_on:
      postgres-iceberg:
        condition: service_healthy
      minio:
        condition: service_healthy
      spark-master:
        condition: service_started
    environment:
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/schema-management/build/libs:/opt/spark/work-dir/jars/schema-management
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf

  # gold-time-dim-loader:
  #   image: project-spark:3.5.0
  #   container_name: gold-time-dim-loader
  #   command: >
  #     /opt/spark/bin/spark-submit
  #     --class csx55.sta.gold.GoldLayerApp
  #     --master spark://spark-master:7077
  #     --deploy-mode client
  #     --conf spark.driver.memory=512m
  #     --conf spark.executor.memory=512m
  #     --conf spark.hadoop.fs.s3a.access.key=admin
  #     --conf spark.hadoop.fs.s3a.secret.key=admin123
  #     --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
  #     --conf spark.hadoop.fs.s3a.path.style.access=true
  #     /opt/spark/work-dir/jars/gold/gold-layer.jar
  #     load-time-dim
  #   depends_on:
  #     gold-table-setup:
  #       condition: service_completed_successfully
  #   environment:
  #     - AWS_ACCESS_KEY_ID=admin
  #     - AWS_SECRET_ACCESS_KEY=admin123
  #     - AWS_REGION=us-east-1
  #   volumes:
  #     - ../lakehouse/gold/build/libs:/opt/spark/work-dir/jars/gold
  #     - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf

  # gold-location-dim-loader:
  #   image: project-spark:3.5.0
  #   container_name: gold-location-dim-loader
  #   command: >
  #     /opt/spark/bin/spark-submit
  #     --class csx55.sta.gold.GoldLayerApp
  #     --master spark://spark-master:7077
  #     --deploy-mode client
  #     --conf spark.driver.memory=512m
  #     --conf spark.executor.memory=512m
  #     --conf spark.hadoop.fs.s3a.access.key=admin
  #     --conf spark.hadoop.fs.s3a.secret.key=admin123
  #     --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
  #     --conf spark.hadoop.fs.s3a.path.style.access=true
  #     /opt/spark/work-dir/jars/gold/gold-layer.jar
  #     load-location-dim
  #   depends_on:
  #     gold-table-setup:
  #       condition: service_completed_successfully
  #     silver-trips-consumer:
  #       condition: service_started
  #   environment:
  #     - AWS_ACCESS_KEY_ID=admin
  #     - AWS_SECRET_ACCESS_KEY=admin123
  #     - AWS_REGION=us-east-1
  #   volumes:
  #     - ../lakehouse/gold/build/libs:/opt/spark/work-dir/jars/gold
  #     - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf

  # gold-trip-metrics:
  #   image: project-spark:3.5.0
  #   container_name: gold-trip-metrics
  #   command: >
  #     /opt/spark/bin/spark-submit
  #     --class csx55.sta.gold.GoldLayerApp
  #     --master spark://spark-master:7077
  #     --deploy-mode client
  #     --conf spark.driver.memory=2g
  #     --conf spark.executor.memory=2g
  #     --conf spark.executor.cores=1
  #     --conf spark.dynamicAllocation.enabled=true
  #     --conf spark.dynamicAllocation.shuffleTracking.enabled=true
  #     --conf spark.dynamicAllocation.minExecutors=1
  #     --conf spark.dynamicAllocation.maxExecutors=2
  #     --conf spark.dynamicAllocation.initialExecutors=1
  #     --conf spark.dynamicAllocation.executorIdleTimeout=60s
  #     --conf spark.dynamicAllocation.schedulerBacklogTimeout=5s
  #     --conf spark.shuffle.service.enabled=true
  #     --conf spark.streaming.kafka.maxRatePerPartition=1000
  #     --conf spark.sql.streaming.minBatchesToRetain=10
  #     --conf spark.driver.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
  #     --conf spark.executor.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
  #     --conf spark.hadoop.fs.s3a.access.key=admin
  #     --conf spark.hadoop.fs.s3a.secret.key=admin123
  #     --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
  #     --conf spark.hadoop.fs.s3a.path.style.access=true
  #     /opt/spark/work-dir/jars/gold/gold-layer.jar
  #     trip-metrics-live

  pipeline-latency-metrics:
    image: project-spark:3.5.0
    container_name: pipeline-latency-metrics
    command: >
      /opt/spark/bin/spark-submit
      --class csx55.sta.gold.GoldLayerApp
      --master spark://spark-master:7077
      --deploy-mode client
      --conf spark.driver.memory=512m
      --conf spark.executor.memory=512m
      --conf spark.executor.cores=1
      --conf spark.dynamicAllocation.enabled=true
      --conf spark.dynamicAllocation.shuffleTracking.enabled=true
      --conf spark.dynamicAllocation.minExecutors=0
      --conf spark.dynamicAllocation.maxExecutors=1
      --conf spark.dynamicAllocation.initialExecutors=1
      --conf spark.dynamicAllocation.executorIdleTimeout=60s
      --conf spark.dynamicAllocation.schedulerBacklogTimeout=5s
      --conf spark.shuffle.service.enabled=true
      --conf spark.streaming.kafka.maxRatePerPartition=1000
      --conf spark.sql.streaming.minBatchesToRetain=10
      --conf spark.driver.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
      --conf spark.executor.extraJavaOptions=-Dlog4j.configurationFile=file:/opt/spark/work-dir/conf/log4j2.properties
      --conf spark.hadoop.fs.s3a.access.key=admin
      --conf spark.hadoop.fs.s3a.secret.key=admin123
      --conf spark.hadoop.fs.s3a.endpoint=http://minio:9000
      --conf spark.hadoop.fs.s3a.path.style.access=true
      /opt/spark/work-dir/jars/gold/gold-layer.jar
      pipeline-latency
    depends_on:
      monitoring-table-setup:
        condition: service_completed_successfully
      silver-trips-consumer:
        condition: service_started
    environment:
      - AWS_ACCESS_KEY_ID=admin
      - AWS_SECRET_ACCESS_KEY=admin123
      - AWS_REGION=us-east-1
    volumes:
      - ../lakehouse/gold/build/libs:/opt/spark/work-dir/jars/gold
      - ../lakehouse/streaming/src/main/resources:/opt/spark/work-dir/conf
      - spark-logs:/opt/spark/logs
      - spark-state:/tmp/state-store
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 1G
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4040/api/v1/applications"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    stop_grace_period: 120s
    restart: unless-stopped


volumes:
  kafka-data:
  spark-logs:
  spark-state:
  minio-data:
  postgres-iceberg-data:
